--Loja Virtual

datatype produto = Smartphone | TV
datatype pessoas = Joao | Maria
produtos = {Smartphone, TV}
produtosBD = {(Smartphone, 450, 3), (TV, 870, 2)}
usuarios = {(Joao, 123), (Maria, 345)}

--O primeiro parâmetro de todos os canais é a identificação do acesso: 1 ou 2.
channel autenticaUsuario:{1..2}.{Joao, Maria}.{123, 456}
channel adicionaCarrinho:{1..2}.produtos
channel acessaProduto:{1..2}.produtos
channel loginFalhou:{1..2}.{0..2}
channel acessoCliente:{1..2}
channel pesquisaProduto:{1..2}
channel confereItens:{1..2}
channel finalizaCompra:{1..2}
channel continuarComprando:{1..2}
channel confirmaEndereco:{1.2}
channel escolherFormaPagamento:{1..2}.{450, 870, 900, 1320, 1740}
channel confirmaPagamento:{1..2}
channel calcularFrete:{1..2}
channel concluirCompra:{1..2}.{450, 870, 900, 1320, 1740}
channel loginOk:{1..2} 
channel cadastrarNovoUsuario:{1..2}
channel exibeInfoProduto:{1..2}.{450,870}
channel removerItem:{1..2}.produtos
channel carrinhoVazio:{1..2}
channel pagamentoBoleto:{1..2}
channel pagamentoDebitoOnline:{1..2}.{450, 870, 900, 1320, 1740}
channel transacaoDebitoOnline:{1..2}.{450, 870, 900, 1320, 1740}
channel pagamentoCartaoCredito:{1..2}.{450, 870, 900, 1320, 1740}
channel confirmaTransacaoCredito:{1..2}
channel negaTransacaoCredito:{1..2}
channel confirmaTransacaoDebito:{1..2}
channel negaTransacaoDebito:{1..2}
channel pagamentoFalha:{1..2}
channel enviaProdutos:{1..2}
channel handshakeBanco:{1..2}.{450, 870, 900, 1320, 1740}
channel aguardaResposta:{1..2}
channel transacaoCredito:{1..2}
channel handshakeOperadora:{1..2}.{450, 870, 900, 1320, 1740}.{Joao, Maria}.{1111111,2222222}.{11,22}
channel informaDadosCartao:{1..2}.{Joao, Maria}.{1111111,2222222}.{11,22}
channel eventoInternoOperadora:{1..2}
channel eventoInternoBanco:{1..2}
channel consultaEstoque:{1..2}.produtos
channel confirmaEstoque:{1..2}.Bool
channel separaEstoque:{1..2}.produtos
channel mensagemEstoqueIndisponivel:{1..2}
channel respostaEstoqueBD:{1..2}.Bool 
channel BDesperaConfirmacao:{1..2}
channel consultaProdutoBD:{1..2}.produtos
channel respostaProdutoBD:{1..2}.produtos.{450, 870, 900, 1320, 1740}.{0..9}

acessosSimultaneos = {1..2}

LOJAVIRTUAL = LOJAVIRTUAL2(seq(produtosBD))

-- Entrelaçamento de acessos + composição generalizada com Banco de Dados da loja
LOJAVIRTUAL2(produtosLoja) =  (||| i:acessosSimultaneos @ ACESSOCLIENTE(i))
												[| {|confirmaEstoque, separaEstoque, respostaEstoqueBD, consultaProdutoBD, respostaProdutoBD|} |]
																	BDLOJA(produtosLoja)

BDLOJA(produtosLoja) = 	(separaEstoque?i?item -> SEPARAESTOQUEBD(i, produtosLoja, item, <>))
							[]
						(consultaProdutoBD?i?item -> CONSULTABD(i, produtosLoja, item))

CONSULTABD(i, produtosLoja, item) = 	let 
										preco = fnPreco(produtosLoja, item)
	 									estoque = fnEstoque(produtosLoja, item) 
	 								within
	 									respostaProdutoBD!i.item.preco.estoque -> BDLOJA(produtosLoja)

SEPARAESTOQUEBD(i, produtosLoja, item, checked) = 	let
														nome = head( seq({nome | (nome, preco, estoque) <- {head(produtosLoja)} }) )
														preco = head( seq({preco | (nome, preco, estoque) <- {head(produtosLoja)} }) )
														estoque = head( seq({estoque | (nome, preco, estoque) <- {head(produtosLoja)} }) )
													within
														if nome == item then
															if estoque > 0 then
																respostaEstoqueBD!i.true -> BDLOJA(<(nome,preco,estoque-1)>^(tail(produtosLoja))^checked)
															else
																respostaEstoqueBD!i.false -> BDLOJA(produtosLoja^checked)
														else
															SEPARAESTOQUEBD(i, tail(produtosLoja), item, checked^<head(produtosLoja)>)

--i=id acesso
ACESSOCLIENTE(i) = acessoCliente.i -> NAVEGACAO(i, <>)

--i=id acesso; c=carrinho
NAVEGACAO(i, c) = pesquisaProduto.i -> acessaProduto.i?item -> DETALHEPRODUTO(i, item, c)

DETALHEPRODUTO(i, item, c) = consultaProdutoBD!i.item -> respostaProdutoBD!i.item?preco?estoque -> 
															if estoque > 0 then
																--ao adicionar item no carrinho a quantidade padrão é 1
																adicionaCarrinho.i.item -> CARRINHO(i, <(item,preco,1)>^c)
															else
																mensagemEstoqueIndisponivel.i -> NAVEGACAO(i, c)

-- Let .. Within
-- DETALHEPRODUTO(i, item, c) = let 
-- 								preco = fnPreco(item)
-- 								estoque = fnEstoque(item) 
-- 							 within
-- 							 	exibeInfoProduto.i.preco.estoque -> adicionaCarrinho.i!item -> CARRINHO(i, <item>^c)

-- Comprehension
fnPreco(produtosLoja, item) = 	let 
									nome = head( seq({nome | (nome, preco, estoque) <- {head(produtosLoja)} }) ) 
									preco = head( seq({preco | (nome, preco, estoque) <- {head(produtosLoja)} }) ) 
								within
									if nome == item then
										preco
									else
										fnPreco(tail(produtosLoja), item)

fnPreco2(item) = head( seq({preco | (nome, preco, estoque) <- {item} }) ) 

fnEstoque(produtosLoja, item) = let 
									nome = head( seq({nome | (nome, preco, estoque) <- {head(produtosLoja)} }) ) 
									estoque = head( seq({estoque | (nome, preco, estoque) <- {head(produtosLoja)} }) ) 
								within
									if nome == item then
										estoque
									else
										fnEstoque(tail(produtosLoja), item)

--i=id acesso; c=carrinho
CARRINHO(i, c) = 	if length(c) == 0 then
						carrinhoVazio.i -> NAVEGACAO(i,c)
					---limite de 2 itens por carrinho (para evitar recursão infinita)
					else if length(c) < 2 and length(c)>0 then 
		  	  			(continuarComprando.i -> NAVEGACAO(i, c)
		  	  				[]
		  	  			concluirCompra.i.fnTotalCarrinho(c,0) -> AUTENTICACAO(i, c, 0)
		  	  				[]
		  	  			-- Restrição de conjunto, só deve ser possível remover o que foi inserido.
		  	  			removerItem!i?iOut:fnIdItens(c,<>) -> CARRINHO(i, fnRemoveItem(iOut, c, <>)))
		  	  		-- Carrinho atingiu limite de itens (não pode continuar comprando)
		  	  		else 
		  	  			concluirCompra.i.fnTotalCarrinho(c,0) -> AUTENTICACAO(i, c, 0)
		  	  				[]
		  	  			-- Restrição de conjunto, só deve ser possível remover o que foi inserido.
		  	  			removerItem!i?iOut:fnIdItens(c,<>) -> CARRINHO(i, fnRemoveItem(iOut, c, <>))

--iOut=item a remover; c=carrinho; checked=lista de itens ja comparados
fnRemoveItem(iOut, c, checked) = 	let 
										item = head(c)
										nome = head( seq({nome | (nome, preco, estoque) <- {item} }) )
						 			within 
						 				if (nome == iOut) then
						 					tail(c) ^ checked
						 				else
					 						fnRemoveItem(iOut, tail(c), checked^<item>)

fnTotalCarrinho(c, t) = if length(c) > 0 then
							fnTotalCarrinho(tail(c), t + fnPreco2( head(c)) )
						 else 
						 	t

fnIdItens(c,idItens) = 	let 
							item = head(c)
							nome = head( seq({nome | (nome, preco, estoque) <- {item} }) ) 
						within
							if length(c) > 0 then
								fnIdItens(tail(c), idItens^<nome>)
							else
								set(idItens)

-- i=id acesso; c=carrinho; n=tentativas de login.
AUTENTICACAO(i, c, n) = autenticaUsuario.i?login.senha -> 
							((loginOk.i -> 

									( (PAGAMENTO(i,c)
										[| {|handshakeBanco, transacaoDebitoOnline, confirmaTransacaoDebito, negaTransacaoDebito|} |] 
												BANCO ) 

									) [| {|handshakeOperadora, transacaoCredito, confirmaTransacaoCredito, negaTransacaoCredito|} |] 
																		OPERADORACARTAO
							) 
					  			|~|
							(loginFalhou.i!n+1 -> 
								if(n+1 < 2) then 
									AUTENTICACAO(i, c, n+1) 
								else
									ACESSOCLIENTE(i)))

PAGAMENTO(i,c) = 	let 
									total = fnTotalCarrinho(c,0) 
								within
									escolherFormaPagamento.i.total -> 
										--eventos sincronizados com BDLOJA (ver composição paralela ACESSOCLIENTE/BDLOJA)
										separaEstoque!i!Smartphone -> respostaEstoqueBD!i?retorno ->
										if (retorno == true) then
											( 
												(pagamentoDebitoOnline!i.total -> PAGAMENTODEBITOONLINE(i,c,total) )
																-- Composição paralela generalizada
													[]
												(pagamentoCartaoCredito!i.total -> PAGAMENTOCREDITO(i, c, total) )	
											)
										else
											mensagemEstoqueIndisponivel.i -> STOP

PAGAMENTODEBITOONLINE(i,c,total) = handshakeBanco!i.total -> transacaoDebitoOnline!i.total -> aguardaResposta!i ->
																	( 
																		(confirmaTransacaoDebito.i -> enviaProdutos.i -> SKIP)
																			[]
																		(negaTransacaoDebito.i -> PAGAMENTO(i,c))
																	)
																
PAGAMENTOCREDITO(i, c, total) = informaDadosCartao!i?nomegrafado?cartao?codigo -> 
									handshakeOperadora.i.total.nomegrafado.cartao.codigo -> aguardaResposta.i ->
														(
															(confirmaTransacaoCredito!i -> enviaProdutos!i -> SKIP)
															[]
															(negaTransacaoCredito!i -> PAGAMENTO(i,c))
														)								

BANCO = handshakeBanco?i?total ->
					(transacaoDebitoOnline!i.total -> eventoInternoBanco!i -> 
															(
																(confirmaTransacaoDebito!i -> SKIP)
																	[]
																(negaTransacaoDebito!i -> SKIP)
															))

OPERADORACARTAO = handshakeOperadora?i?total?nomegrafado?cartao?codigo -> eventoInternoOperadora!i ->
															(
																(confirmaTransacaoCredito!i -> SKIP)
																	[]
																(negaTransacaoCredito!i -> SKIP)
															)
			


assert LOJAVIRTUAL :[deadlock free[F]] -- PASSED
assert LOJAVIRTUAL :[deterministic [F]] -- FAIL
assert LOJAVIRTUAL :[divergence free [FD]] -- PASSED


--TODO versão normal: 
--acrescentar valor. OK
--controle de estoque (concorrencia por recursos)
--acrescentar paralelismo sincronizado com cliente e/ou operadora de cartão de crédito. OK
--frete?

--
--TODO versão refinada: 
--retirar não determinismo do login
--acrescentar possibilidade de cadastro de novo usuário e usar hiding para comparar
-- CADASTRONOVOUSUARIO(i,c,n) = cadastrarNovoUsuario.i -> AUTENTICACAO(i,c,n)
-- retirar o paralelismo generalizado entre PAGAMENTO e BANCO, e colocar em ACESSOS / BANCO para retirar o deadlock do skip.

-- BANCO = --transacaoBoleto -> transfereSaldo -> confirmaTransacao
-- -- 		--[]
--  		transacaoDebitoOnline.total.contaEmpresa -> 
--  						recebeDadosConta?cartao.senha ->
--  												(dadosContaOK -> verificaSaldo.conta -> 
--  																	(saldoOK -> debitaConta.conta -> creditaConta.contaEmpresa
--  																	 									-> confirmaTransacao -> BANCO)
--  																		[]
--  																	(saldoInsuficiente -> negaTransacao -> BANCO)
--  														[]
--  												(dadosContaInvalidos -> negaTransacao -> BANCO)

-- OPERADORACARTAO = transacaoCartao -> checaDadosUsuario -> checaCreditoCliente -> autorizaPagamento