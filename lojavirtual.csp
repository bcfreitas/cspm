--Loja Virtual

datatype produto = Smartphone | TV
datatype pessoas = Joao | Maria
produtos = {(Smartphone, 450, 3), (TV, 870, 2)}
usuarios = {(Joao, 123), (Maria, 345)}
teste = <1,2>

--O primeiro parâmetro de todos os canais é a identificação do acesso: 1 ou 2.
channel autenticaUsuario:{1..2}.{Joao, Maria}.{123, 456}
channel adicionaCarrinho:{1..2}.produtos
channel acessaProduto:{1..2}.produtos
channel loginFalhou:{1..2}.{0..2}
channel acessoCliente:{1..2}
channel pesquisaProduto:{1..2}
channel confereItens:{1..2}
channel finalizaCompra:{1..2}
channel continuarComprando:{1..2}
channel confirmaEndereco:{1.2}
channel escolherFormaPagamento:{1..2}.{450, 870, 900, 1320, 1740}
channel confirmaPagamento:{1..2}
channel calcularFrete:{1..2}
channel concluirCompra:{1..2}.{450, 870, 900, 1320, 1740}
channel loginOk:{1..2} 
channel cadastrarNovoUsuario:{1..2}
channel exibeInfoProduto:{1..2}.{450,870}
channel removerItem:produtos
channel carrinhoVazio:{1..2}
channel pagamentoBoleto
channel pagamentoDebitoOnline:{450, 870, 900, 1320, 1740}
channel transacaoDebitoOnline:{450, 870, 900, 1320, 1740}
channel pagamentoCartaoCredito:{450, 870, 900, 1320, 1740}
channel confirmaTransacao
channel negaTransacao
channel pagamentoFalha
channel enviaProdutos
channel handshakeBanco:{450, 870, 900, 1320, 1740}
channel aguardaResposta
channel transacaoCredito
channel handshakeOperadora:{450, 870, 900, 1320, 1740}.{Joao, Maria}.{1111111,2222222}.{11,22}
channel informaDadosCartao:{Joao, Maria}.{1111111,2222222}.{11,22}
channel eventoInternoOperadora
channel eventoInternoBanco
channel consultaEstoque:produtos
channel confirmaEstoque:Bool
channel separaEstoque
channel mensagemEstoqueIndisponivel:{1..2}
channel respostaBD:Bool 
channel BDesperaConfirmacao

acessosSimultaneos = {1..2}

LOJAVIRTUAL = LOJAVIRTUAL2(produtos)

-- Entrelaçamento de acessos
LOJAVIRTUAL2(produtosLoja) =  (||| i:acessosSimultaneos @ ACESSOCLIENTE(i, produtosLoja))
												[| {|confirmaEstoque, separaEstoque, respostaBD|} |]
													BDLOJA(produtosLoja)

BDLOJA(produtosLoja) = 	((confirmaEstoque!true -> BDLOJA(produtosLoja))
													[]
												(separaEstoque -> respostaBD!true -> BDesperaConfirmacao  -> BDLOJA(produtosLoja)))

--i=id acesso
ACESSOCLIENTE(i, produtosLoja) = acessoCliente.i -> NAVEGACAO(i, <>, produtosLoja)

--i=id acesso; c=carrinho
NAVEGACAO(i, c, produtosLoja) = pesquisaProduto.i -> acessaProduto.i?item -> DETALHEPRODUTO(i, item, c, produtosLoja)

-- Let .. Within
DETALHEPRODUTO(i, item, c, produtosLoja) = let 
								preco = fnPreco(item) 
							 within
							 	exibeInfoProduto.i.preco -> adicionaCarrinho.i!item -> CARRINHO(i, <item>^c, produtosLoja)

-- Comprehension
fnPreco(item) = head( seq({preco | (nome, preco, estoque) <- {item} }) )

--i=id acesso; c=carrinho
CARRINHO(i, c, produtosLoja) = 	if length(c) == 0 then
						carrinhoVazio.i -> NAVEGACAO(i,c,produtosLoja)
					---limite de 2 itens por carrinho (para evitar recursão infinita)
					else if length(c) < 2 and length(c)>0 then 
		  	  			(continuarComprando.i -> NAVEGACAO(i, c, produtosLoja)
		  	  				[]
		  	  			concluirCompra.i.fnTotalCarrinho(c,0) -> AUTENTICACAO(i, c, 0, produtosLoja)
		  	  				[]
		  	  			-- Restrição de conjunto, só deve ser possível remover o que foi inserido.
		  	  			removerItem?iOut:set(c) -> CARRINHO(i, fnRemoveItem(iOut, c, <>), produtosLoja))
		  	  		-- Carrinho atingiu limite de itens (não pode continuar comprando)
		  	  		else 
		  	  			concluirCompra.i.fnTotalCarrinho(c,0) -> AUTENTICACAO(i, c, 0, produtosLoja)
		  	  				[]
		  	  			-- Restrição de conjunto, só deve ser possível remover o que foi inserido.
		  	  			removerItem?iOut:set(c) -> CARRINHO(i, fnRemoveItem(iOut, c, <>), produtosLoja)

--iOut=item a remover; c=carrinho; checked=lista de itens ja comparados
fnRemoveItem(iOut, c, checked) = 	let 
										item = head(c)
						 			within 
						 				if (item == iOut) then
						 					tail(c) ^ checked
						 				else
					 						fnRemoveItem(iOut, tail(c), checked ^ <item>)

fnTotalCarrinho(c, t) = if length(c) > 0 then
							fnTotalCarrinho(tail(c), t + fnPreco( head(c)) )
						 else 
						 	t

-- i=id acesso; c=carrinho; n=tentativas de login.
AUTENTICACAO(i, c, n, produtosLoja) = autenticaUsuario.i?login.senha -> 
							((loginOk.i -> PAGAMENTO(i,c,produtosLoja))
					  			|~|
							(loginFalhou.i!n+1 -> 
								if(n+1 < 2) then 
									AUTENTICACAO(i, c, n+1, produtosLoja) 
								else
									ACESSOCLIENTE(i, produtosLoja)))

PAGAMENTO(i,c,produtosLoja) = 	let 
									total = fnTotalCarrinho(c,0) 
								within
									escolherFormaPagamento.i.total -> 
										--eventos sincronizados com BDLOJA (ver composição paralela ACESSOCLIENTE/BDLOJA)
										separaEstoque -> respostaBD?retorno ->
										if (retorno == true) then
											( 
												(pagamentoDebitoOnline.total -> 
																-- Composição paralela generalizada
																( PAGAMENTODEBITOONLINE(i,c,total,produtosLoja) 
																	[| {|handshakeBanco, transacaoDebitoOnline, confirmaTransacao, 
																		negaTransacao|} |] 
																	BANCO ))
													[]
												(pagamentoCartaoCredito.total ->	
																( PAGAMENTOCREDITO(i, c, total, produtosLoja)
																	[| {|handshakeOperadora, transacaoCredito, confirmaTransacao, negaTransacao|} |] 
																		OPERADORACARTAO
																	))
											)
										else
											mensagemEstoqueIndisponivel.i -> ACESSOCLIENTE(i,produtosLoja)

PAGAMENTODEBITOONLINE(i,c,total,produtosLoja) = handshakeBanco.total -> transacaoDebitoOnline.total -> aguardaResposta ->
																	((confirmaTransacao -> enviaProdutos -> ACESSOCLIENTE(i,produtosLoja))
																	[]
																	(negaTransacao -> PAGAMENTO(i,c,produtosLoja)))
																
PAGAMENTOCREDITO(i, c, total,produtosLoja) = informaDadosCartao?nomegrafado?cartao?codigo -> 
									handshakeOperadora.total.nomegrafado.cartao.codigo -> aguardaResposta ->
														(
															(confirmaTransacao -> enviaProdutos -> ACESSOCLIENTE(i,produtosLoja))
															[]
															(negaTransacao -> PAGAMENTO(i,c,produtosLoja))
														)								

BANCO = handshakeBanco?total ->
					(transacaoDebitoOnline.total -> eventoInternoBanco -> 
															(
																(confirmaTransacao -> SKIP)
																	[]
																(negaTransacao -> SKIP)
															))

OPERADORACARTAO = handshakeOperadora?total?nomegrafado?cartao?codigo -> eventoInternoOperadora ->
															(
																(confirmaTransacao -> SKIP)
																	[]
																(negaTransacao -> SKIP)
															)
			


assert LOJAVIRTUAL :[deadlock free[F]] -- PASSED
assert LOJAVIRTUAL :[deterministic [F]] -- FAIL
assert LOJAVIRTUAL :[divergence free [FD]] -- PASSED


--TODO versão normal: 
--acrescentar valor. OK
--controle de estoque (concorrencia por recursos)
--acrescentar paralelismo sincronizado com cliente e/ou operadora de cartão de crédito. OK
--frete?

--
--TODO versão refinada: 
--retirar não determinismo do login
--acrescentar possibilidade de cadastro de novo usuário e usar hiding para comparar
-- CADASTRONOVOUSUARIO(i,c,n) = cadastrarNovoUsuario.i -> AUTENTICACAO(i,c,n)
-- retirar o paralelismo generalizado entre PAGAMENTO e BANCO, e colocar em ACESSOS / BANCO para retirar o deadlock do skip.

-- BANCO = --transacaoBoleto -> transfereSaldo -> confirmaTransacao
-- -- 		--[]
--  		transacaoDebitoOnline.total.contaEmpresa -> 
--  						recebeDadosConta?cartao.senha ->
--  												(dadosContaOK -> verificaSaldo.conta -> 
--  																	(saldoOK -> debitaConta.conta -> creditaConta.contaEmpresa
--  																	 									-> confirmaTransacao -> BANCO)
--  																		[]
--  																	(saldoInsuficiente -> negaTransacao -> BANCO)
--  														[]
--  												(dadosContaInvalidos -> negaTransacao -> BANCO)

-- OPERADORACARTAO = transacaoCartao -> checaDadosUsuario -> checaCreditoCliente -> autorizaPagamento