--Loja Virtual

datatype produto = Smartphone | TV
datatype pessoas = Joao | Maria
produtos = {Smartphone, TV}
produtosBD = {(Smartphone, 100, 2), (TV, 200, 1)}

--os conjuntos abaixo foram criados para melhorar o desempenho do FDR
totaisPossiveis = {100,200,300,400}
precosUnitariosPossiveis = {100,200}

usuarios = {(Joao, 123), (Maria, 345)}
nomesPossiveis = {Joao, Maria}

--{450, 870, 900, 1320, 1740}
--O primeiro parâmetro de todos os canais é a identificação do acesso: 1 ou 2.
channel autenticaUsuario:{1..2}.{Joao, Maria}.{123, 345}
channel adicionaCarrinho:{1..2}.produtos
channel acessaProduto:{1..2}.produtos
channel loginFalhou:{1..2}
channel acessoCliente:{1..2}
channel pesquisaProduto:{1..2}
channel confereItens:{1..2}
channel finalizaCompra:{1..2}
channel continuarComprando:{1..2}
channel confirmaEndereco:{1.2}
channel escolherFormaPagamento:{1..2}.totaisPossiveis
channel confirmaPagamento:{1..2}
channel calcularFrete:{1..2}
channel concluirCompra:{1..2}.totaisPossiveis
channel loginOk:{1..2} 
channel cadastrarNovoUsuario:{1..2}
channel exibeInfoProduto:{1..2}.{1..10}
channel removerItem:{1..2}.produtos
channel carrinhoVazio:{1..2}
channel pagamentoBoleto:{1..2}
channel pagamentoDebitoOnline:{1..2}.totaisPossiveis
channel transacaoDebitoOnline:{1..2}.totaisPossiveis.{333333,444444}.nomesPossiveis.{321,654}
channel pagamentoCartaoCredito:{1..2}.totaisPossiveis
channel confirmaTransacaoCredito:{1..2}.Bool 
channel negaTransacaoCredito:{1..2}
channel confirmaTransacaoDebito:{1..2}.Bool
channel negaTransacaoDebito:{1..2}
channel pagamentoFalha:{1..2}
channel enviaProdutos:{1..2}
channel handshakeBanco:{1..2}.totaisPossiveis
channel aguardaResposta:{1..2}
channel transacaoCredito:{1..2}
channel handshakeOperadora:{1..2}.totaisPossiveis.{Joao, Maria}.{1111111,2222222}.{11,22}
channel informaDadosCartao:{1..2}.{Joao, Maria}.{1111111,2222222}.{11,22}
channel eventoInternoOperadora:{1..2}
channel eventoInternoBanco:{1..2}
channel consultaEstoque:{1..2}.produtos
channel separaEstoque:{1..2}.produtos
channel reverteEstoque:{1..2}.produtos
channel mensagemEstoqueIndisponivel:{1..2}.produtos
channel respostaEstoqueBD:{1..2}.Bool.precosUnitariosPossiveis
channel BDesperaConfirmacao:{1..2}
channel consultaProdutoBD:{1..2}.produtos
channel respostaProdutoBD:{1..2}.produtos.precosUnitariosPossiveis.{0..9}
channel entradaNovosProdutos

acessosSimultaneos = {1..2}

LOJAVIRTUAL = LOJAVIRTUAL2(seq(produtosBD))

-- Entrelaçamento de acessos + composição generalizada com Banco de Dados da loja
LOJAVIRTUAL2(produtosLoja) =  ( ( ( (||| i:acessosSimultaneos @ ACESSOCLIENTE(i))
												[| {|separaEstoque, respostaEstoqueBD, consultaProdutoBD, respostaProdutoBD, reverteEstoque|} |]
																	BDLOJA(produtosLoja) \{|entradaNovosProdutos|})
												[| {|handshakeBanco, confirmaTransacaoDebito|} |] 
																	BANCO )
												[| {|handshakeOperadora, transacaoCredito, confirmaTransacaoCredito|} |] 
																	OPERADORACARTAO ) 

BDLOJA(produtosLoja) = 	(consultaProdutoBD?i?item -> CONSULTABD(i, produtosLoja, item))
							[]
						(separaEstoque?i?item -> SEPARAESTOQUEBD(i, produtosLoja, item, <>))
							[]
						(reverteEstoque?i?item -> REVERTEESTOQUEBD(i, produtosLoja, item, <>))
							[]
						(entradaNovosProdutos -> BDLOJA(produtosLoja))


CONSULTABD(i, produtosLoja, item) = 	let 
										preco = fnPreco(produtosLoja, item)
	 									estoque = fnEstoque(produtosLoja, item) 
	 								within
	 									respostaProdutoBD!i.item.preco.estoque -> BDLOJA(produtosLoja)

SEPARAESTOQUEBD(i, produtosLoja, item, checked) = 	let
														nome = head( seq({nome | (nome, preco, estoque) <- {head(produtosLoja)} }) )
														preco = head( seq({preco | (nome, preco, estoque) <- {head(produtosLoja)} }) )
														estoque = head( seq({estoque | (nome, preco, estoque) <- {head(produtosLoja)} }) )
													within
														if nome == item then
															if estoque > 0 then
																respostaEstoqueBD!i.true.preco -> BDLOJA(<(nome,preco,estoque-1)>^(tail(produtosLoja))^checked)
															else
																respostaEstoqueBD!i.false.preco -> BDLOJA(produtosLoja^checked)
														else
															SEPARAESTOQUEBD(i, tail(produtosLoja), item, checked^<head(produtosLoja)>)

REVERTEESTOQUEBD(i, produtosLoja, item, checked) = 	let
														nome = head( seq({nome | (nome, preco, estoque) <- {head(produtosLoja)} }) )
														preco = head( seq({preco | (nome, preco, estoque) <- {head(produtosLoja)} }) )
														estoque = head( seq({estoque | (nome, preco, estoque) <- {head(produtosLoja)} }) )
													within
														if nome == item then
															-- 9 é o limite máximo de estoque de itens, definido no canal respostaProdutoBD
															if estoque < 9 then
																BDLOJA(<(nome,preco,estoque+1)>^(tail(produtosLoja))^checked)
															else
																BDLOJA(<(nome,preco,estoque)>^(tail(produtosLoja))^checked)
														else
															REVERTEESTOQUEBD(i, tail(produtosLoja), item, checked^<head(produtosLoja)>)

--i=id acesso
ACESSOCLIENTE(i) = acessoCliente.i -> NAVEGACAO(i, <>)

--i=id acesso; c=carrinho
NAVEGACAO(i, c) = pesquisaProduto.i -> acessaProduto.i?item ->  DETALHEPRODUTO(i, item, c)

-- ao visualizar o detalhe de um produto, o cliente pode adicionar ao carrinho, fazendo com que seja separado estoque no banco.
DETALHEPRODUTO(i, item, c) =	consultaProdutoBD!i!item -> respostaProdutoBD!i?item?preco?estoque ->
														(if estoque > 0 then
															(adicionaCarrinho.i.item -> 
																(
																--separaEstoque e RespostaEstoqueBD são sincronizados com BDLOJA
																separaEstoque!i!item -> 
																	respostaEstoqueBD!i?retorno?preco ->
																				if retorno == true then
																					--ao adicionar item no carrinho a quantidade padrão é 1
																					CARRINHO(i, <(item,preco,1)>^c)
																				else
																					mensagemEstoqueIndisponivel.i.item -> 
																								NAVEGACAO(i, c) 
																)
															)
															else
																mensagemEstoqueIndisponivel.i.item -> 
																								NAVEGACAO(i, c)
														)

-- Comprehension
fnPreco(produtosLoja, item) = 	let 
									nome = head( seq({nome | (nome, preco, estoque) <- {head(produtosLoja)} }) ) 
									preco = head( seq({preco | (nome, preco, estoque) <- {head(produtosLoja)} }) ) 
								within
									if nome == item then
										preco
									else
										fnPreco(tail(produtosLoja), item)

fnPreco2(item) = head( seq({preco | (nome, preco, estoque) <- {item} }) ) 

fnEstoque(produtosLoja, item) = let 
									nome = head( seq({nome | (nome, preco, estoque) <- {head(produtosLoja)} }) ) 
									estoque = head( seq({estoque | (nome, preco, estoque) <- {head(produtosLoja)} }) ) 
								within
									if nome == item then
										estoque
									else
										fnEstoque(tail(produtosLoja), item)

--i=id acesso; c=carrinho
CARRINHO(i, c) = 	if length(c) == 0 then
						carrinhoVazio.i -> NAVEGACAO(i,c)
					---limite de 2 itens por carrinho (para evitar recursão infinita)
					else if length(c) < 2 and length(c)>0 then 
		  	  			(continuarComprando.i -> NAVEGACAO(i, c)
		  	  				[]
		  	  			concluirCompra.i.fnTotalCarrinho(c,0) -> AUTENTICACAO(i, c, 0)
		  	  				[]
		  	  			-- Restrição de conjunto, só deve ser possível remover o que foi inserido.
		  	  			-- reverteEstoque é sincronizado com BDLOJA
		  	  			removerItem!i?iOut:fnIdItens(c,<>) -> reverteEstoque!i.iOut -> CARRINHO(i, fnRemoveItem(iOut, c, <>)))
		  	  		-- Carrinho atingiu limite de itens (não pode continuar comprando)
		  	  		else 
		  	  			concluirCompra.i.fnTotalCarrinho(c,0) -> AUTENTICACAO(i, c, 0)
		  	  				[]
		  	  			-- Restrição de conjunto, só deve ser possível remover o que foi inserido.
		  	  			-- reverteEstoque é sincronizado com BDLOJA
		  	  			removerItem!i?iOut:fnIdItens(c,<>) -> reverteEstoque!i.iOut -> CARRINHO(i, fnRemoveItem(iOut, c, <>))

--iOut=item a remover; c=carrinho; checked=lista de itens ja comparados
fnRemoveItem(iOut, c, checked) = 	let 
										item = head(c)
										nome = head( seq({nome | (nome, preco, estoque) <- {item} }) )
						 			within 
						 				if (nome == iOut) then
						 					tail(c) ^ checked
						 				else
					 						fnRemoveItem(iOut, tail(c), checked^<item>)

fnTotalCarrinho(c, t) = if length(c) > 0 then
							fnTotalCarrinho(tail(c), t + fnPreco2( head(c)) )
						 else 
						 	t

fnIdItens(c,idItens) = 	let 
							item = head(c)
							nome = head( seq({nome | (nome, preco, estoque) <- {item} }) ) 
						within
							if length(c) > 0 then
								fnIdItens(tail(c), idItens^<nome>)
							else
								set(idItens)

-- i=id acesso; c=carrinho; n=tentativas de login.
AUTENTICACAO(i, c, n) = autenticaUsuario.i?login.senha -> 
													(
														(loginOk.i -> PAGAMENTOref(i,c) )
											  				|~|
														(loginFalhou.i -> 	if(n+1 < 2) then 
																					AUTENTICACAO(i, c, n+1) 
																				else
																					ACESSOCLIENTE(i))
													)

PAGAMENTO(i,c) = 	let 
						total = fnTotalCarrinho(c,0) 
					within
						escolherFormaPagamento.i.total -> 
									((pagamentoDebitoOnline!i.total -> PAGAMENTODEBITOONLINE(i,c,total))
										[]
									(pagamentoCartaoCredito!i.total -> PAGAMENTOCREDITO(i, c, total)))	

--eventos sincronizados com BANCO (ver composição paralela)
PAGAMENTODEBITOONLINE(i,c,total) = handshakeBanco!i.total -> aguardaResposta!i ->
																	( 
																		(confirmaTransacaoDebito!i?true -> enviaProdutos.i -> ACESSOCLIENTE(i))
																			|~|
																		(confirmaTransacaoDebito!i?false -> PAGAMENTO(i,c))
																	)

--eventos sincronizados com OPERADORACARTAO (ver composição paralela)																
PAGAMENTOCREDITO(i, c, total) = informaDadosCartao!i?nomegrafado?cartao?codigo -> 
									handshakeOperadora.i.total.nomegrafado.cartao.codigo -> aguardaResposta.i ->
														(
															(confirmaTransacaoCredito!i?true -> enviaProdutos!i -> ACESSOCLIENTE(i))
																|~|
															(confirmaTransacaoCredito!i?false -> PAGAMENTO(i,c))
														)								

BANCO = handshakeBanco?i?total ->
					transacaoDebitoOnline!i.total?conta?usuario?senha -> 
														eventoInternoBanco!i -> 
															(
																(confirmaTransacaoDebito!i!true -> BANCO)
																	|~|
																(confirmaTransacaoDebito!i!false -> BANCO)
															)

OPERADORACARTAO = handshakeOperadora?i?total?nomegrafado?cartao?codigo -> eventoInternoOperadora!i ->
															(
																(confirmaTransacaoCredito!i!true -> OPERADORACARTAO)
																	|~|
																(confirmaTransacaoCredito!i!false -> OPERADORACARTAO)
															)
			


assert LOJAVIRTUAL :[deadlock free[F]] -- PASSED
assert LOJAVIRTUAL :[deterministic [F]] -- FAIL
assert LOJAVIRTUAL :[divergence free [FD]] -- PASSED


--TODO versão normal: 
--acrescentar valor. OK
--controle de estoque (concorrencia por recursos) OK
--acrescentar paralelismo sincronizado com cliente e/ou operadora de cartão de crédito. OK 
--frete? 

--
--TODO versão refinada: 
--retirar não determinismo do login OK
--acrescentar possibilidade de cadastro de novo usuário e usar hiding para comparar
-- CADASTRONOVOUSUARIO(i,c,n) = cadastrarNovoUsuario.i -> AUTENTICACAO(i,c,n)
-- retirar o paralelismo generalizado entre PAGAMENTO e BANCO, e colocar em ACESSOS / BANCO para retirar o deadlock do skip. OK



---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
--RRRRRRRRRRRRRRRRR                          ffffffffffffffff    iiii                                                d::::::d                  
--R::::::::::::::::R                        f::::::::::::::::f  i::::i                                               d::::::d                  
--R::::::RRRRRR:::::R                      f::::::::::::::::::f  iiii                                                d::::::d                  
--RR:::::R     R:::::R                     f::::::fffffff:::::f                                                      d:::::d                   
--  R::::R     R:::::R    eeeeeeeeeeee     f:::::f       ffffffiiiiiiinnnn  nnnnnnnn      aaaaaaaaaaaaa      ddddddddd:::::d   aaaaaaaaaaaaa   
--  R::::R     R:::::R  ee::::::::::::ee   f:::::f             i:::::in:::nn::::::::nn    a::::::::::::a   dd::::::::::::::d   a::::::::::::a  
--  R::::RRRRRR:::::R  e::::::eeeee:::::eef:::::::ffffff        i::::in::::::::::::::nn   aaaaaaaaa:::::a d::::::::::::::::d   aaaaaaaaa:::::a 
--  R:::::::::::::RR  e::::::e     e:::::ef::::::::::::f        i::::inn:::::::::::::::n           a::::ad:::::::ddddd:::::d            a::::a 
--  R::::RRRRRR:::::R e:::::::eeeee::::::ef::::::::::::f        i::::i  n:::::nnnn:::::n    aaaaaaa:::::ad::::::d    d:::::d     aaaaaaa:::::a 
--  R::::R     R:::::Re:::::::::::::::::e f:::::::ffffff        i::::i  n::::n    n::::n  aa::::::::::::ad:::::d     d:::::d   aa::::::::::::a 
--  R::::R     R:::::Re::::::eeeeeeeeeee   f:::::f              i::::i  n::::n    n::::n a::::aaaa::::::ad:::::d     d:::::d  a::::aaaa::::::a 
--  R::::R     R:::::Re:::::::e            f:::::f              i::::i  n::::n    n::::na::::a    a:::::ad:::::d     d:::::d a::::a    a:::::a 
--RR:::::R     R:::::Re::::::::e          f:::::::f            i::::::i n::::n    n::::na::::a    a:::::ad::::::ddddd::::::dda::::a    a:::::a 
--R::::::R     R:::::R e::::::::eeeeeeee  f:::::::f            i::::::i n::::n    n::::na:::::aaaa::::::a d:::::::::::::::::da:::::aaaa::::::a 
--R::::::R     R:::::R  ee:::::::::::::e  f:::::::f            i::::::i n::::n    n::::n a::::::::::aa:::a d:::::::::ddd::::d a::::::::::aa:::a
--RRRRRRRR     RRRRRRR    eeeeeeeeeeeeee  fffffffff            iiiiiiii nnnnnn    nnnnnn  aaaaaaaaaa  aaaa  ddddddddd   ddddd  aaaaaaaaaa  aaaa

--(cartao, cdc, nome, limite de credito)
repositorioCartoes={(1111111, 11, Joao, 500), (2222222, 22, Maria, 100)}
--(conta, usuario, senha, saldo em conta)
repositorioContas={(333333, Joao, 321, 100), (444444, Maria, 654, 300)}

LOJAVIRTUALref = LOJAVIRTUAL2ref(seq(produtosBD))

-- Entrelaçamento de acessos + composição generalizada com Banco de Dados da loja
LOJAVIRTUAL2ref(produtosLoja) =  ( ( ( ( (||| i:acessosSimultaneos @ ACESSOCLIENTEref(i))
												[| {|separaEstoque, respostaEstoqueBD, consultaProdutoBD, respostaProdutoBD, reverteEstoque|} |]
																	BDLOJAref(produtosLoja) \ {|entradaNovosProdutos|} )
												[| {|autenticaUsuario, loginOk, loginFalhou|} |] 
																	BDLOJA2ref(seq(usuarios) ) )
												[| {|handshakeBanco, confirmaTransacaoDebito|} |] 
																	BANCOref(seq(repositorioContas) ) )
												[| {|handshakeOperadora, transacaoCredito, confirmaTransacaoCredito|} |] 
																	OPERADORACARTAOref(seq(repositorioCartoes)) ) 


BDLOJAref(produtosLoja) = 	if 
								fnEstoqueZerado(produtosLoja)
							then
								(consultaProdutoBD?i?item -> CONSULTABDref(i, produtosLoja, item))
									[]
								(separaEstoque?i?item -> SEPARAESTOQUEBDref(i, produtosLoja, item, <>))
									[]
								(reverteEstoque?i?item -> REVERTEESTOQUEBDref(i, produtosLoja, item, <>))
									[]
								(entradaNovosProdutos -> BDLOJAref(seq(produtosBD)))
							else
								(consultaProdutoBD?i?item -> CONSULTABDref(i, produtosLoja, item))
									[]
								(separaEstoque?i?item -> SEPARAESTOQUEBDref(i, produtosLoja, item, <>))
									[]
								(reverteEstoque?i?item -> REVERTEESTOQUEBDref(i, produtosLoja, item, <>))	

fnEstoqueZerado(produtosLoja) = if length(produtosLoja)>0 then
									let
										estoque = head( seq({estoque | (nome, preco, estoque) <- {head(produtosLoja)} }) )
									within
										if estoque>0 then
											false
										else
											fnEstoqueZerado(tail(produtosLoja))
								else
									true

BDLOJA2ref(usuarios) = autenticaUsuario?i?nome?senha -> AUTENTICAUSUARIOBDref(i, nome, senha, usuarios, <>)


CONSULTABDref(i, produtosLoja, item) = 	let 
										preco = fnPreco(produtosLoja, item)
	 									estoque = fnEstoque(produtosLoja, item) 
	 								within
	 									respostaProdutoBD!i.item.preco.estoque -> BDLOJAref(produtosLoja)

SEPARAESTOQUEBDref(i, produtosLoja, item, checked) = 	let
														nome = head( seq({nome | (nome, preco, estoque) <- {head(produtosLoja)} }) )
														preco = head( seq({preco | (nome, preco, estoque) <- {head(produtosLoja)} }) )
														estoque = head( seq({estoque | (nome, preco, estoque) <- {head(produtosLoja)} }) )
													within
														if nome == item then
															if estoque > 0 then
																respostaEstoqueBD!i.true.preco -> BDLOJAref(<(nome,preco,estoque-1)>^(tail(produtosLoja))^checked)
															else
																respostaEstoqueBD!i.false.preco -> BDLOJAref(produtosLoja^checked)
														else
															SEPARAESTOQUEBDref(i, tail(produtosLoja), item, checked^<head(produtosLoja)>)

REVERTEESTOQUEBDref(i, produtosLoja, item, checked) = 	let
														nome = head( seq({nome | (nome, preco, estoque) <- {head(produtosLoja)} }) )
														preco = head( seq({preco | (nome, preco, estoque) <- {head(produtosLoja)} }) )
														estoque = head( seq({estoque | (nome, preco, estoque) <- {head(produtosLoja)} }) )
													within
														if nome == item then
															if estoque < 9 then
																BDLOJAref(<(nome,preco,estoque+1)>^(tail(produtosLoja))^checked)
															else
																BDLOJAref(<(nome,preco,estoque)>^(tail(produtosLoja))^checked)
														else
															REVERTEESTOQUEBDref(i, tail(produtosLoja), item, checked^<head(produtosLoja)>)

AUTENTICAUSUARIOBDref(i, nome, senha, usuarios, checked) = 	
															let
																nomeBD = head( seq({nome | (nome, senha) <- {head(usuarios)} }) )
																senhaBD = head( seq({senha | (nome, senha) <- {head(usuarios)} }) )
															within
																if nome == nomeBD then
																	if senha == senhaBD then
																		loginOk.i -> BDLOJA2ref(usuarios^checked)
																	else 
																		loginFalhou.i -> BDLOJA2ref(usuarios^checked)
																else 
																	AUTENTICAUSUARIOBDref(i, nome, senha, tail(usuarios), <head(usuarios)>^checked)

--i=id acesso
ACESSOCLIENTEref(i) = acessoCliente.i -> NAVEGACAOref(i, <>)

--i=id acesso; c=carrinho
NAVEGACAOref(i, c) = pesquisaProduto.i -> acessaProduto.i?item ->  DETALHEPRODUTOref(i, item, c)

-- ao visualizar o detalhe de um produto, o cliente pode adicionar ao carrinho, fazendo com que seja separado estoque no banco.
DETALHEPRODUTOref(i, item, c) =	consultaProdutoBD!i!item -> respostaProdutoBD!i?item?preco?estoque ->
														(if estoque > 0 then
															(adicionaCarrinho.i.item -> 
																(
																--separaEstoque e RespostaEstoqueBD são sincronizados com BDLOJA
																separaEstoque!i!item -> 
																	respostaEstoqueBD!i?retorno?preco ->
																				if retorno == true then
																					--ao adicionar item no carrinho a quantidade padrão é 1
																					CARRINHOref(i, <(item,preco,1)>^c)
																				else
																					mensagemEstoqueIndisponivel.i.item -> 
																								NAVEGACAOref(i, c) 
																)
															)
															else
																mensagemEstoqueIndisponivel.i.item -> 
																								NAVEGACAOref(i, c)
														)

--i=id acesso; c=carrinho
CARRINHOref(i, c) = 	if length(c) == 0 then
						carrinhoVazio.i -> NAVEGACAOref(i,c)
					---limite de 2 itens por carrinho (para evitar recursão infinita)
					else if length(c) < 2 and length(c)>0 then 
		  	  			(continuarComprando.i -> NAVEGACAOref(i, c)
		  	  				[]
		  	  			concluirCompra.i.fnTotalCarrinho(c,0) -> AUTENTICACAOref(i, c, 0)
		  	  				[]
		  	  			-- Restrição de conjunto, só deve ser possível remover o que foi inserido.
		  	  			-- reverteEstoque é sincronizado com BDLOJA
		  	  			removerItem!i?iOut:fnIdItens(c,<>) -> reverteEstoque!i.iOut -> CARRINHOref(i, fnRemoveItem(iOut, c, <>)))
		  	  		-- Carrinho atingiu limite de itens (não pode continuar comprando)
		  	  		else 
		  	  			concluirCompra.i.fnTotalCarrinho(c,0) -> AUTENTICACAOref(i, c, 0)
		  	  				[]
		  	  			-- Restrição de conjunto, só deve ser possível remover o que foi inserido.
		  	  			-- reverteEstoque é sincronizado com BDLOJA
		  	  			removerItem!i?iOut:fnIdItens(c,<>) -> reverteEstoque!i.iOut -> CARRINHOref(i, fnRemoveItem(iOut, c, <>))

-- i=id acesso; c=carrinho; n=tentativas de login.
AUTENTICACAOref(i, c, n) = autenticaUsuario.i?login.senha -> 
													(
														(loginOk.i -> PAGAMENTOref(i,c) )
											  				[]
														(loginFalhou.i -> 	if(n+1 < 2) then 
																					AUTENTICACAOref(i, c, n+1) 
																				else
																					ACESSOCLIENTEref(i))
													)

PAGAMENTOref(i,c) = 	let 
									total = fnTotalCarrinho(c,0) 
								within
									escolherFormaPagamento.i.total -> 
												((pagamentoDebitoOnline!i.total -> PAGAMENTODEBITOONLINEref(i,c,total))
													[]
												(pagamentoCartaoCredito!i.total -> PAGAMENTOCREDITOref(i, c, total)))	

--eventos sincronizados com BANCO (ver composição paralela)
PAGAMENTODEBITOONLINEref(i,c,total) = handshakeBanco!i.total -> 
																		aguardaResposta!i ->
																			confirmaTransacaoDebito!i?resposta -> 
																				if resposta == true then
																					enviaProdutos.i -> ACESSOCLIENTEref(i)
																				else
																					PAGAMENTOref(i,c)

--eventos sincronizados com OPERADORACARTAO (ver composição paralela)																
PAGAMENTOCREDITOref(i, c, total) = informaDadosCartao!i?nome?cartao?codigo -> 
									handshakeOperadora.i.total.nome.cartao.codigo -> aguardaResposta.i ->
															confirmaTransacaoCredito!i?resposta ->
																if resposta == true then
																	enviaProdutos!i -> ACESSOCLIENTEref(i)
																else
																	 PAGAMENTOref(i,c)

BANCOref(repositorioContas) = handshakeBanco?i?total ->
					transacaoDebitoOnline!i.total?conta?usuario?senha ->
													 eventoInternoBanco!i -> AUTORIZACAOBANCOref(i, total, conta, usuario, senha, repositorioContas, <>)

AUTORIZACAOBANCOref(i, total,conta,usuario,senha,repositorioContas, checked) =  
									let 
										contaBD = head(seq({conta | (conta, usuario, senha, saldo) <- {head(repositorioContas)} }))	
										usuarioBD = head(seq({usuario | (conta, usuario, senha, saldo) <- {head(repositorioContas)} }))	
										senhaBD = head(seq({senha | (conta, usuario, senha, saldo) <- {head(repositorioContas)} }))	
										saldo = head(seq({saldo | (conta, usuario, senha, saldo) <- {head(repositorioContas)} }))	
									within
										if 
											-- chave primaria da busca
											conta==contaBD 
										then
											if
												--os dados de login no sistema bancário estão ok.
												usuario==usuarioBD and senha==senhaBD 
											then
												if 
													-- há saldo disponível na conta
													saldo >= total
												then
													-- autoriza transação
													confirmaTransacaoDebito!i!true -> BANCOref(<(conta, usuario, senha, saldo-total)>^tail(repositorioContas)^checked)
												else
													-- não há saldo, não autoriza
													confirmaTransacaoDebito!i!false -> BANCOref(repositorioContas^checked)
											else
												-- os dados de login não conferem, nega transação
												confirmaTransacaoDebito!i!false -> BANCOref(repositorioContas^checked)
										else
											-- não é o registro desejado, busca o próximo.
											AUTORIZACAOBANCOref(i,total,conta,usuario,senha, tail(repositorioContas), <head(repositorioContas)>^checked )


OPERADORACARTAOref(repositorioCartoes) = handshakeOperadora?i?total?nome?cartao?codigo -> 
													eventoInternoOperadora!i -> AUTORIZACAOOPERADORAref(i, total, cartao, codigo, nome, repositorioCartoes,<>) 

AUTORIZACAOOPERADORAref(i, total, cartao, codigo, nome, repositorioCartoes, checked) = 	
						let
							cartaoBD = head(seq({cartao | (cartao, codigo, nome, credito) <- {head(repositorioCartoes)} }))	
							codigoBD = head(seq({codigo | (cartao, codigo, nome, credito) <- {head(repositorioCartoes)} }))	
							nomeBD = head(seq({nome | (cartao, codigo, nome, credito) <- {head(repositorioCartoes)} }))
							credito = head(seq({credito | (cartao, codigo, nome, credito) <- {head(repositorioCartoes)} }))	
						within
							if 
								--a chave primaria na busca
								cartao==cartaoBD 
							then
								if
									--os parâmetros informados para o cartão estão corretos
									codigo==codigoBD and nome==nomeBD 
								then
									if 
										--há limite de crédito disponível para o cliente
										credito >= total 
									then
										-- autoriza e diminui limite do cliente
										confirmaTransacaoCredito!i!true -> 
											OPERADORACARTAOref(<(cartaoBD, codigoBD, nome, credito-total)>^tail(repositorioCartoes^checked))
									else
										-- não há limite disponível: não autoriza
										confirmaTransacaoCredito!i!false -> OPERADORACARTAOref(repositorioCartoes^checked)
								else
									-- os parâmetros informados do cartão são inválidos, nega transação.
									confirmaTransacaoCredito!i!false -> OPERADORACARTAOref(repositorioCartoes^checked)
							else
								-- não é o registro desejado, passa para o próximo.
								AUTORIZACAOOPERADORAref(i, total, cartao, codigo, nome, tail(repositorioCartoes), <head(repositorioCartoes)>^checked)
								


assert LOJAVIRTUALref :[deadlock free[F]] -- PASSED
assert LOJAVIRTUALref :[deterministic [F]] -- PASSED
assert LOJAVIRTUALref :[divergence free [FD]] -- PASSED

assert LOJAVIRTUAL [T= LOJAVIRTUALref -- PASSED
assert LOJAVIRTUALref [T= LOJAVIRTUAL -- FAIL

assert LOJAVIRTUAL \{| autenticaUsuario, loginOk, loginFalhou |} [F= LOJAVIRTUALref \{| autenticaUsuario, loginOk, loginFalhou |} -- PASSED
assert LOJAVIRTUALref  \{| autenticaUsuario, loginOk, loginFalhou |} [F= LOJAVIRTUAL \{| autenticaUsuario, loginOk, loginFalhou |} -- PASSED

assert LOJAVIRTUAL [FD= LOJAVIRTUALref
assert LOJAVIRTUALref [FD= LOJAVIRTUAL
