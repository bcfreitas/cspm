--Loja Virtual

datatype produto = Smartphone | TV
datatype pessoas = Joao | Maria
produtos = {(Smartphone, 450, 3), (TV, 870, 2)}
usuarios = {(Joao, 123), (Maria, 345)}

--O primeiro parâmetro de todos os canais é a identificação do acesso: 1 ou 2.
channel autenticaUsuario:{1..2}.{Joao, Maria}.{123, 456}
channel adicionaCarrinho:{1..2}.produtos
channel acessaProduto:{1..2}.produtos
channel loginFalhou:{1..2}.{0..2}
channel acessoCliente:{1..2}
channel pesquisaProduto:{1..2}
channel confereItens:{1..2}
channel finalizaCompra:{1..2}
channel continuarComprando:{1..2}
channel confirmaEndereco:{1.2}
channel escolherFormaPagamento:{1..2}.{450, 870, 900, 1320, 1740}
channel confirmaPagamento:{1..2}
channel calcularFrete:{1..2}
channel concluirCompra:{1..2}.{450, 870, 900, 1320, 1740}
channel loginOk:{1..2} 
channel cadastrarNovoUsuario:{1..2}
channel exibeInfoProduto:{1..2}.{450,870}
channel removerItem:produtos
channel carrinhoVazio:{1..2}
channel pagamentoBoleto
channel pagamentoDebitoOnline:{450, 870, 900, 1320, 1740}
channel transacaoDebitoOnline:{450, 870, 900, 1320, 1740}
channel pagamentoCartaoCredito:{450, 870, 900, 1320, 1740}
channel confirmaTransacao
channel negaTransacao
channel pagamentoFalha
channel enviaProdutos
channel handshakeBanco:{450, 870, 900, 1320, 1740}
channel aguardaResposta
channel transacaoCredito
channel handshakeOperadora:{450, 870, 900, 1320, 1740}.{Joao, Maria}.{1111111,2222222}.{11,22}
channel informaDadosCartao:{Joao, Maria}.{1111111,2222222}.{11,22}
channel eventoInternoOperadora

acessosSimultaneos = {1..2}

-- Entrelaçamento de acessos
LOJAVIRTUAL =  ||| i:acessosSimultaneos @ ACESSOCLIENTE(i)

--i=id acesso
ACESSOCLIENTE(i) = acessoCliente.i -> NAVEGACAO(i, <>)

--i=id acesso; c=carrinho
NAVEGACAO(i, c) = pesquisaProduto.i -> acessaProduto.i?item -> DETALHEPRODUTO(i, item, c)

-- Let .. Within
DETALHEPRODUTO(i, item, c) = let 
								preco = fnPreco(item) 
							 within
							 	exibeInfoProduto.i.preco -> adicionaCarrinho.i!item -> CARRINHO(i, <item>^c)

-- Comprehension
fnPreco(item) = head( seq({preco | (nome, preco, estoque) <- {item} }) )

--i=id acesso; c=carrinho
CARRINHO(i, c) = 	if length(c) == 0 then
						carrinhoVazio.i -> NAVEGACAO(i,c)
					---limite de 2 itens por carrinho (para evitar recursão infinita)
					else if length(c) < 2 and length(c)>0 then 
		  	  			(continuarComprando.i -> NAVEGACAO(i, c)
		  	  				[]
		  	  			concluirCompra.i.fnTotalCarrinho(c,0) -> AUTENTICACAO(i, c, 0)
		  	  				[]
		  	  			-- Restrição de conjunto, só deve ser possível remover o que foi inserido.
		  	  			removerItem?iOut:set(c) -> CARRINHO(i, fnRemoveItem(iOut, c, <>)))
		  	  		-- Carrinho atingiu limite de itens (não pode continuar comprando)
		  	  		else 
		  	  			concluirCompra.i.fnTotalCarrinho(c,0) -> AUTENTICACAO(i, c, 0)
		  	  				[]
		  	  			-- Restrição de conjunto, só deve ser possível remover o que foi inserido.
		  	  			removerItem?iOut:set(c) -> CARRINHO(i, fnRemoveItem(iOut, c, <>))

--iOut=item a remover; c=carrinho; checked=lista de itens ja comparados
fnRemoveItem(iOut, c, checked) = 	let 
										item = head(c)
						 			within 
						 				if (item == iOut) then
						 					tail(c) ^ checked
						 				else
					 						fnRemoveItem(iOut, tail(c), checked ^ <item>)

fnTotalCarrinho(c, t) = if length(c) > 0 then
							fnTotalCarrinho(tail(c), t + fnPreco( head(c)) )
						 else 
						 	t

-- i=id acesso; c=carrinho; n=tentativas de login.
AUTENTICACAO(i, c, n) = autenticaUsuario.i?login.senha -> 
							((loginOk.i -> PAGAMENTO(i,c))
					  			|~|
							(loginFalhou.i!n+1 -> 
								if(n+1 < 2) then 
									AUTENTICACAO(i, c, n+1) 
								else
									ACESSOCLIENTE(i)))

PAGAMENTO(i,c) = let total = fnTotalCarrinho(c,0) within
						escolherFormaPagamento.i.total ->
						( 
							(pagamentoDebitoOnline.total -> 
											-- Composição paralela generalizada
											( PAGAMENTODEBITOONLINE(i,c,total) 
												[| {|handshakeBanco, transacaoDebitoOnline, confirmaTransacao, negaTransacao|} |] 
													BANCO ))
								[]
							(pagamentoCartaoCredito.total ->	
											( PAGAMENTOCREDITO(i, c, total)
												[| {|handshakeOperadora, transacaoCredito, confirmaTransacao, negaTransacao|} |] 
													OPERADORACARTAO
												))
						)
							

PAGAMENTODEBITOONLINE(i,c,total) = handshakeBanco.total -> transacaoDebitoOnline.total -> aguardaResposta ->
														(
															(confirmaTransacao -> enviaProdutos -> ACESSOCLIENTE(i))
															[]
															(negaTransacao -> PAGAMENTO(i,c))
														)

PAGAMENTOCREDITO(i, c, total) = informaDadosCartao?nomegrafado?cartao?codigo -> 
									handshakeOperadora.total.nomegrafado.cartao.codigo -> aguardaResposta ->
														(
															(confirmaTransacao -> enviaProdutos -> ACESSOCLIENTE(i))
															[]
															(negaTransacao -> PAGAMENTO(i,c))
														)								

channel eventoInternoBanco

BANCO = handshakeBanco?total ->
					(transacaoDebitoOnline.total -> eventoInternoBanco -> 
															(
																(confirmaTransacao -> SKIP)
																	[]
																(negaTransacao -> SKIP)
															))

OPERADORACARTAO = handshakeOperadora?total?nomegrafado?cartao?codigo -> eventoInternoOperadora ->
															(
																(confirmaTransacao -> SKIP)
																	[]
																(negaTransacao -> SKIP)
															)
			


assert LOJAVIRTUAL :[deadlock free[F]] -- PASSED
assert LOJAVIRTUAL :[deterministic [F]] -- FAIL
assert LOJAVIRTUAL :[divergence free [FD]] -- PASSED


--TODO versão normal: 
--acrescentar valor. 
--controle de estoque (concorrencia por recursos)
--acrescentar paralelismo sincronizado com cliente e/ou operadora de cartão de crédito.
--frete?

--
--TODO versão refinada: 
--retirar não determinismo do login
--acrescentar possibilidade de cadastro de novo usuário e usar hiding para comparar
-- CADASTRONOVOUSUARIO(i,c,n) = cadastrarNovoUsuario.i -> AUTENTICACAO(i,c,n)
-- retirar o paralelismo generalizado entre PAGAMENTO e BANCO, e colocar em ACESSOS / BANCO para retirar o deadlock do skip.

-- BANCO = --transacaoBoleto -> transfereSaldo -> confirmaTransacao
-- -- 		--[]
--  		transacaoDebitoOnline.total.contaEmpresa -> 
--  						recebeDadosConta?cartao.senha ->
--  												(dadosContaOK -> verificaSaldo.conta -> 
--  																	(saldoOK -> debitaConta.conta -> creditaConta.contaEmpresa
--  																	 									-> confirmaTransacao -> BANCO)
--  																		[]
--  																	(saldoInsuficiente -> negaTransacao -> BANCO)
--  														[]
--  												(dadosContaInvalidos -> negaTransacao -> BANCO)

-- OPERADORACARTAO = transacaoCartao -> checaDadosUsuario -> checaCreditoCliente -> autorizaPagamento